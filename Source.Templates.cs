namespace Monkeymoto.InlineCollections
{
    internal static partial class Source
    {
        /////////////////////////////////////////////////
        ////////////////// DO NOT MOVE //////////////////
        /////////////////////////////////////////////////
        private const string Template_MethodBody_Template =
@"
        {{{{{{{0}}}
        }}}}";

        private static readonly string Template_MethodBody_Arg0 = string.Format
        (
            Template_MethodBody_Template,
            "0"
        );

        private static readonly string Template_MethodBody_Arg1 = string.Format
        (
            Template_MethodBody_Template,
            "1"
        );
        /////////////////////////////////////////////////
        /////////////////////////////////////////////////

        private const string Template_ArrayConversionOperators =
@"
        public static explicit operator {0}[]({1} collection) =>
            ((ReadOnlySpan<{0}>)collection).ToArray();
        public static explicit operator {1}({0}[] array) =>
            Implementation.FromArray<{1}, {0}>(array);";

        private const string Template_AsSpanReadOnlySpanMethods_Template =
@"
        /// <summary>
        /// Creates a new read-only span over the collection.
        /// </summary>
        /// <returns>The new read-only span over the elements of the collection.</returns>
        readonly {{0}}ReadOnlySpan<{{1}}> {{2}}AsReadOnlySpan() => {0};
        /// <summary>
        /// Creates a new span over the collection.
        /// </summary>
        /// <returns>The new span over the elements of the collection.</returns>
        {{0}}Span<{{1}}> {{2}}AsSpan() => {1};";

        private static readonly string Template_AsSpanReadOnlySpanMethods = string.Format
        (
            Template_AsSpanReadOnlySpanMethods_Template,
            Template_CreateReadOnlySpan,
            Template_CreateSpan
        );

        private const string Template_ClearMethod =
@"
        /// <summary>
        /// Assigns the default value to each element of the collection.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This method does not remove any elements from the collection.
        /// </para>
        /// </remarks>
        public void Clear() => this = default;";

        private const string Template_CollectionBuilderAttribute =
@"
    [CollectionBuilder(typeof({0}), ""Create"")]";

        private const string Template_CollectionBuilderClassDeclaration =
@"
    
    file static class {0}
    {{
        public static {1} Create{2}(ReadOnlySpan<{3}> span) =>
            Implementation.FromReadOnlySpan<{1}, {3}>(span);
    }}";

        private const string Template_ContainsMethod =
@"
        /// <summary>
        /// Returns a value indicating whether a specified element occurs within this collection.
        /// </summary>
        /// <returns>
        /// <see langword=""true"" /> if the specified element is found within the collection; otherwise
        /// <see langword=""false"" />.
        /// </returns>
        public readonly bool Contains({0} item) => Implementation.Contains(this, item);";

        private const string Template_CopyToMethod =
@"
        /// <summary>
        /// Copies the contents of this collection into a destination <see cref=""System.Span{{T}}"">Span&lt;{0}&gt;</see>.
        /// </summary>
        /// <exception cref=""ArgumentOutOfRangeException"">
        /// The collection was larger than the size of the specified destination span.
        /// </exception>
        public readonly void CopyTo(Span<{0}> destination) => Implementation.CopyTo(this, destination, nameof(destination));";

        private const string Template_CreateReadOnlySpan = "MemoryMarshal.CreateReadOnlySpan(in {3}, {4})";

        private const string Template_CreateSpan = "MemoryMarshal.CreateSpan(ref {3}, {4})";

        private const string Template_DefaultConstructor =
@"
        /// <summary>
        /// Initializes a new instance of the collection with all elements set to their default value.
        /// </summary>
        public {0}() => this = default;";

        private const string Template_FileHeader =
@"// <auto-generated>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Monkeymoto.InlineCollections;
using static Monkeymoto.InlineCollections.ExceptionMessages;

#nullable disable

{0}
namespace Monkeymoto.InlineCollections
{{
    file static class Implementation
    {{
        public static bool Contains<T>(ReadOnlySpan<T> span, T item) => IndexOf(span, item) != -1;

        public static void CopyTo<T>
        (
            ReadOnlySpan<T> source,
            Array destination,
            int arrayIndex,
            string targetParamName,
            [CallerArgumentExpression(nameof(destination))]
            string arrayIndexParamName = null
        )
        {{
            if (destination is not T[] destinationArray)
            {{
                throw new ArgumentException({1}, arrayIndexParamName);
            }}
            CopyTo(source, destinationArray, arrayIndex, targetParamName, arrayIndexParamName);
        }}
        
        public static void CopyTo<T>
        (
            ReadOnlySpan<T> source,
            T[] destination,
            int arrayIndex,
            string targetParamName,
            [CallerArgumentExpression(nameof(destination))]
            string arrayIndexParamName = null
        )
        {{
            ArgumentNullException.ThrowIfNull(destination);
            if ((arrayIndex < 0) || (arrayIndex >= destination.Length))
            {{
                throw new ArgumentOutOfRangeException(arrayIndexParamName, {2});
            }}
            var destinationSpan = new Span<T>(destination, arrayIndex, destination.Length - arrayIndex);
            CopyTo(source, destinationSpan, targetParamName);
        }}
        
        public static void CopyTo<T>(ReadOnlySpan<T> source, Span<T> destination, string targetParamName)
        {{
            if (!source.TryCopyTo(destination))
            {{
                throw new ArgumentOutOfRangeException(targetParamName, {3});
            }}
        }}
        
        public static void CopyTo<TCollection, TElement>
        (
            ReadOnlySpan<TElement> source,
            scoped ref TCollection destination,
            string targetParamName
        )
            where TCollection : struct, IInlineCollection<TElement>
        {{
            CopyTo(source, destination.AsSpan(), targetParamName);
        }}
        
        public static TCollection FromArray<TCollection, TElement>
        (
            TElement[] array,
            [CallerArgumentExpression(nameof(array))]
            string paramName = null
        )
            where TCollection : struct, IInlineCollection<TElement>
        {{
            ArgumentNullException.ThrowIfNull(array, paramName);
            return FromReadOnlySpan<TCollection, TElement>(array, paramName);
        }}
        
        public static TCollection FromReadOnlySpan<TCollection, TElement>
        (
            ReadOnlySpan<TElement> span,
            [CallerArgumentExpression(nameof(span))]
            string paramName = null
        )
            where TCollection : struct, IInlineCollection<TElement>
        {{
            TCollection result = default;
            CopyTo(span, ref result, paramName);
            return result;
        }}
        
        public static T GetItem<T>
        (
            ReadOnlySpan<T> span,
            int index,
            [CallerArgumentExpression(nameof(index))]
            string indexParamName = null
        )
        {{
            if ((index < 0) || (index >= span.Length))
            {{
                throw new ArgumentOutOfRangeException(indexParamName, {4});
            }}
            return span[index];
        }}
        
        public static int IndexOf<T>(ReadOnlySpan<T> span, T item)
        {{
            for (int i = 0; i < span.Length; ++i)
            {{
#nullable enable
                if (span[i]?.Equals(item) ?? item is null)
#nullable disable
                {{
                    return i;
                }}
            }}
            return -1;
        }}
        
        public static void SetItem<T>
        (
            Span<T> span,
            int index,
            in T value,
            [CallerArgumentExpression(nameof(index))]
            string indexParamName = null
        )
        {{
            if ((index < 0) || (index >= span.Length))
            {{
                throw new ArgumentOutOfRangeException(indexParamName, {4});
            }}
            span[index] = value;
        }}
        
        public static void SetItem<T>
        (
            Span<T> span,
            int index,
            object value,
            [CallerArgumentExpression(nameof(index))]
            string indexParamName = null,
            [CallerArgumentExpression(nameof(value))]
            string valueParamName = null
        )
        {{
            if (value is not T item)
            {{
                throw new ArgumentException({5}, valueParamName);
            }}
            SetItem(span, index, in item, indexParamName);
        }}
        
        public static int IStructuralComparable_CompareTo<TCollection, TElement>
        (
            ReadOnlySpan<TElement> collectionSpan,
            object other,
            IComparer comparer,
            [CallerArgumentExpression(nameof(other))]
            string otherParamName = null
        )
            where TCollection : struct, IInlineCollection<TElement>
        {{
            ArgumentNullException.ThrowIfNull(comparer);
            if (other is null)
            {{
                return 1;
            }}
            if (other is not TCollection otherCollection)
            {{
                throw new ArgumentException({5}, otherParamName);
            }}
            var otherCollectionSpan = otherCollection.AsReadOnlySpan();
            for (int i = 0, result = 0; i < collectionSpan.Length; ++i)
            {{
                result = comparer.Compare(collectionSpan[i], otherCollectionSpan[i]);
                if (result != 0)
                {{
                    return result;
                }}
            }}
            return 0;
        }}
        
        public static bool IStructuralEquatable_Equals<TCollection, TElement>
        (
            ReadOnlySpan<TElement> collectionSpan,
            object other,
            IEqualityComparer comparer,
            [CallerArgumentExpression(nameof(other))]
            string otherParamName = null
        )
            where TCollection : struct, IInlineCollection<TElement>
        {{
            ArgumentNullException.ThrowIfNull(comparer);
            if (other is not TCollection otherCollection)
            {{
                return false;
            }}
            var otherCollectionSpan = otherCollection.AsReadOnlySpan();
            for (int i = 0; i < collectionSpan.Length; ++i)
            {{
                if (!comparer.Equals(collectionSpan[i], otherCollectionSpan[i]))
                {{
                    return false;
                }}
            }}
            return true;
        }}
        
        public static int IStructuralEquatable_GetHashCode<TElement>
        (
            ReadOnlySpan<TElement> collectionSpan,
            IEqualityComparer comparer
        )
        {{
            ArgumentNullException.ThrowIfNull(comparer);
            HashCode hashCode = default;
            for (int i = Math.Max(collectionSpan.Length - 8, 0); i < collectionSpan.Length; ++i)
            {{
                hashCode.Add(comparer.GetHashCode(collectionSpan[i]));
            }}
            return hashCode.ToHashCode();
        }}
    }}
    
    file interface IInlineCollection<TElement>
    {{
        public ReadOnlySpan<TElement> AsReadOnlySpan();
        public Span<TElement> AsSpan();
    }}
}}";

        private const string Template_FileFooter =
@"

#nullable restore";

        private const string Template_FillMethod =
@"
        /// <summary>
        /// Fills the elements of this collection with a specified value.
        /// </summary>
        public void Fill({0} value) => ((Span<{0}>)this).Fill(value);";

        private const string Template_GetEnumerator_Body =
@"
            for (int i = 0; i < {0}; ++i)
            {{
                yield return this[i];
            }}";

        private static readonly string Template_GetEnumeratorMethod_ImplExplicit = string.Format
        (
            Template_GetEnumeratorMethod_Template,
            string.Empty,
            "IEnumerator<{0}>",
            Template_MethodBody_Arg1
        );

        private static readonly string Template_GetEnumeratorMethod_ImplRefStructEnumerator = string.Format
        (
            Template_GetEnumeratorMethod_Template,
@"
        [UnscopedRef]",
            "Enumerator",
            " => new(this);"
        );

        private const string Template_GetEnumeratorMethod_Template =
@"
        /// <summary>
        /// Returns an enumerator that iterates through the collection.
        /// </summary>
        /// <returns>An enumerator that can be used to iterate through the collection.</returns>{0}
        public {1} GetEnumerator(){2}";

        private const string Template_ICollection =
@"
        readonly int ICollection.Count => {0};
        readonly bool ICollection.IsSynchronized => false;
        object ICollection.SyncRoot => throw new NotSupportedException({1});
        readonly void ICollection.CopyTo(Array array, int arrayIndex) =>
            Implementation.CopyTo<{2}>(this, array, arrayIndex, nameof(array));";

        private const string Template_ICollectionT =
@"
        readonly int ICollection<{0}>.Count => {1};
        readonly bool ICollection<{0}>.IsReadOnly => true;
        void ICollection<{0}>.Add({0} item) => throw new NotSupportedException({2});
        void ICollection<{0}>.Clear() => throw new NotSupportedException({2});{3}
        readonly void ICollection<{0}>.CopyTo({0}[] array, int arrayIndex) =>
            Implementation.CopyTo(this, array, arrayIndex, nameof(array));
        bool ICollection<{0}>.Remove({0} item) => throw new NotSupportedException({2});";

        private const string Template_ICollectionT_Contains_ImplExplicit =
@"
        readonly bool ICollection<{0}>.Contains({0} item) => Implementation.Contains(this, item);";

        private static readonly string Template_IEnumerable_ImplExplicit = string.Format
        (
            Template_IEnumerable_Template,
            Template_MethodBody_Arg0
        );

        private static readonly string Template_IEnumerable_ImplIEnumerableT = string.Format
        (
            Template_IEnumerable_Template,
            " => ((IEnumerable<{0}>)this).GetEnumerator();"
        );

        private static readonly string Template_IEnumerable_ImplMethod = string.Format
        (
            Template_IEnumerable_Template,
            " => GetEnumerator();"
        );

        private static readonly string Template_IEnumerable_ImplRefStructEnumerator = string.Format
        (
            Template_IEnumerable_Template,
            Template_IEnumerable_RefStructEnumeratorConversion
        );

        private const string Template_IEnumerable_RefStructEnumeratorConversion =
@" =>
            throw new NotSupportedException(NotSupportedException_RefStructEnumeratorConversion);";

        private const string Template_IEnumerable_Template =
@"
        IEnumerator IEnumerable.GetEnumerator(){0}";

        private static readonly string Template_IEnumerableT_ImplExplicit = string.Format
        (
            Template_IEnumerableT_Template,
            Template_MethodBody_Arg1
        );

        private static readonly string Template_IEnumerableT_ImplRefStructEnumerator = string.Format
        (
            Template_IEnumerableT_Template,
            Template_IEnumerable_RefStructEnumeratorConversion
        );

        private const string Template_IEnumerableT_Template =
@"
        IEnumerator<{{0}}> IEnumerable<{{0}}>.GetEnumerator(){0}";

        private static readonly string Template_IInlineCollection_ImplExplicit = Template_AsSpanReadOnlySpanMethods;

        private const string Template_IList =
@"
        readonly bool IList.IsFixedSize => true;
        readonly bool IList.IsReadOnly => false;
        
        object IList.this[int index]
        {{
            readonly get => Implementation.GetItem<{0}>(this, index);
            set => Implementation.SetItem<{0}>(this, index, value);
        }}
        
        int IList.Add(object value) => throw new NotSupportedException({1});
        void IList.Clear() => throw new NotSupportedException({1});
        readonly bool IList.Contains(object value) => value is {0} item && Implementation.Contains(this, item);
        readonly int IList.IndexOf(object value) => value is {0} item ? Implementation.IndexOf(this, item) : -1;
        void IList.Insert(int index, object value) => throw new NotSupportedException({1});
        void IList.Remove(object value) => throw new NotSupportedException({1});
        void IList.RemoveAt(int index) => throw new NotSupportedException({1});";

        private const string Template_IListT =
@"
        {0} IList<{0}>.this[int index]
        {{
            readonly get => Implementation.GetItem<{0}>(this, index);
            set => Implementation.SetItem<{0}>(this, index, in value);
        }}
        {1}
        void IList<{0}>.Insert(int index, {0} item) => throw new NotSupportedException({2});
        void IList<{0}>.RemoveAt(int index) => throw new NotSupportedException({2});";

        private const string Template_IListT_IndexOf_ImplExplict =
@"
        readonly int IList<{0}>.IndexOf({0} item) => Implementation.IndexOf(this, item);";

        private const string Template_IndexOfMethod =
@"
        /// <summary>
        /// Searches for the specified item and returns the index of its first occurrence.
        /// </summary>
        /// <returns>The index of the occurrence of the item in the collection. If not found, returns -1.</returns>
        public readonly int IndexOf({0} item) => Implementation.IndexOf(this, item);";

        private const string Template_InlineCollection =
@"
namespace {0}
{{{1}{2}
}}";

        private const string Template_InlineCollection_StructDeclaration =
@"
    [InlineArray({0})]{1}
    {2} struct {3} :
        {4}
    {{{5}
    }}";

        private const string Template_InlineCollectionAttribute =
@"// <auto-generated>
using System;

#if !MONKEYMOTO_INLINECOLLECTIONS_TYPES_ALREADY_DEFINED

namespace Monkeymoto.InlineCollections
{
    [AttributeUsage(AttributeTargets.Struct, AllowMultiple = false)]
    internal sealed class InlineCollectionAttribute(InlineCollectionOptions flags = default) : Attribute
    {
        public InlineCollectionOptions Flags => flags;
        public required int Length { get; init; }
    }
}

#endif // !MONKEYMOTO_INLINECOLLECTIONS_TYPES_ALREADY_DEFINED

";

        private const string Template_IReadOnlyCollectionT =
@"
        readonly int IReadOnlyCollection<{0}>.Count => {1};";

        private const string Template_IReadOnlyListT =
@"
        readonly {0} IReadOnlyList<{0}>.this[int index] => Implementation.GetItem<{0}>(this, index);";

        private const string Template_IStructuralComparable =
@"
        readonly int IStructuralComparable.CompareTo(object other, IComparer comparer) =>
            Implementation.IStructuralComparable_CompareTo<{0}, {1}>(this, other, comparer);";

        private const string Template_IStructuralEquatable =
@"
        readonly bool IStructuralEquatable.Equals(object other, IEqualityComparer comparer) =>
            Implementation.IStructuralEquatable_Equals<{0}, {1}>(this, other, comparer);
        readonly int IStructuralEquatable.GetHashCode(IEqualityComparer comparer) =>
            Implementation.IStructuralEquatable_GetHashCode<{1}>(this, comparer);";

        private const string Template_NewLine =
@"
";

        private const string Template_NewLineIndent2 =
@"
        ";

        private const string Template_LengthProperty =
@"
        /// <summary>
        /// Gets the total number of elements in the collection.
        /// </summary>
        /// <returns>The total number of elements in the collection.</returns>
        public readonly int Length => {0};";

        private const string Template_ReadOnlySpanConstructor =
@"
        /// <summary>
        /// Initializes a new instance of the collection to the elements in the specified read-only span.
        /// </summary>
        /// <exception cref=""ArgumentOutOfRangeException"">
        /// The specified read-only span was larger than the size of the collection.
        /// </exception>
        public {0}(ReadOnlySpan<{1}> span) => Implementation.CopyTo(span, ref this, nameof(span));";

        private const string Template_RefStructEnumerator =
@"
        /// <summary>
        /// Enumerates the elements of a <see cref=""{0}""/>.
        /// </summary>
        public ref struct Enumerator
        {{
            private Span<{1}>.Enumerator enumerator;
            
            /// <summary>
            /// Initializes the enumerator.
            /// </summary>
            /// <param name=""collection"">The collection to enumerate.</param>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal Enumerator(Span<{1}> collection)
            {{
                enumerator = collection.GetEnumerator();
            }}
            
            /// <summary>
            /// Advances the enumerator to the next element of the collection.
            /// </summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public bool MoveNext() => enumerator.MoveNext();
        }}";

        private const string Template_ToArrayMethod =
@"
        /// <summary>
        /// Copies the contents of this collection into a new array.
        /// </summary>
        /// <returns>An array containing the elements in this collection.</returns>
        public readonly {0}[] ToArray() => ((ReadOnlySpan<{0}>)this).ToArray();";

        private const string Template_TryCopyToMethod =
@"
        /// <summary>
        /// Attempts to copy the contents of this collection into a <see cref=""System.Span{{T}}"">Span&lt;{0}&gt;</see> and
        /// returns a value to indicate whether or not the operation succeeded.
        /// </summary>
        /// <returns>
        /// <see langword=""true"" /> if the copy operation succeeded; otherwise, <see langword=""false"" />.
        /// </returns>
        public readonly bool TryCopyTo(Span<{0}> destination) => ((ReadOnlySpan<{0}>)this).TryCopyTo(destination);";
    }
}
